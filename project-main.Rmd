---
title: "project-main"
author: "Yiran Yao"
date: "2025-08-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      warning = FALSE 
                      #fig.width = 8, 
                      #fig.height = 6, 
                      #dpi = 300, 
                      #cache = TRUE
                      )
```

```{r library}
library(tidyverse)
library(janitor)
library(lubridate)
library(forecast)
#library(feasts)
#library(fable)
#library(fabletools)
#library(tsibble)
library(fpp3)
library(urca)
#library(plotly)
```

```{r load-data}
city_indexes <- read_csv("data/city_indexes.csv")
factor_trends <- read_csv("data/df_factor_trends.csv")
reg_coefs <- read_csv("data/df_reg_coefs.csv")

pcs <- read_csv("data/df_pcs.csv")
eofs_city <- read_csv("data/df_eofs_city.csv")
eofs <- read_csv("data/df_eofs.csv")
```

```{r clean-data}
city_indexes <- city_indexes |> 
  clean_names() 
```

```{r city-index-eda, eval = FALSE}
# transform df to long format 
city_indexes_long <- city_indexes |>
  pivot_longer(
    cols = -month_date,        
    names_to = "city",
    values_to = "index"
  )

# separate city capitals and the rest of the state for clear visualization
capitals <- c(
  "australian_capital_territory",
  "greater_adelaide","greater_brisbane","greater_darwin","greater_hobart",
  "greater_melbourne","greater_perth","greater_sydney"
)
city_indexes_grouped <- city_indexes_long |> 
  mutate(group = ifelse(city %in% capitals, "Capital cities", "Rest of state"))

# plot city capitals 
ggplot(
  filter(city_indexes_grouped, group == "Capital cities"),
  aes(month_date, index, colour = city)
) +
  geom_line() +
  labs(
    title = "City Indexes: Capital Cities",
    x = "Month",
    y = "Index",
    colour = "City"
  ) +
  theme_minimal()

# plot rest of the state 
ggplot(
  filter(city_indexes_grouped, group == "Rest of state"),
  aes(month_date, index, colour = city)
) +
  geom_line() +
  labs(
    title = "City Indexes: Rest of State",
    x = "Month",
    y = "Index",
    colour = "Region"
  ) +
  theme_minimal()

# calculate and rank total growth 
city_growth <- city_indexes_long |>
  group_by(city) |>
  summarise(growth = last(index) - first(index)) |>
  arrange(desc(growth))

# plot the rank of growth 
ggplot(city_growth, aes(x = reorder(city, growth), y = growth)) +
  geom_col() +
  coord_flip() +
  labs(title = "Total Growth of Cities", x = "City", y = "Growth")
```

# Fitting Time Series Model on the Mining Trend 

```{r}
# create tsibble object 
mining_trend <- factor_trends |>
  transmute(
    month_date = yearmonth(as.Date(month_date)), # change format to yyyy-m 
    mining = as.numeric(mining)
  ) |>
  as_tsibble(index = month_date)
```

## Exploratory Data Analysis

Exploratory plots and statistical summaries are used to identify key patterns in the mining trend (Brisbane – Sydney spread) series and to guide the choice of an appropriate model for this data. 

Findings: 

* Time plot: The trend displays a prolonged, uneven rise from 2003 to 2012, followed by a sharp regime shift, then COVID-related fluctuations, with the level adjusting and showing time-varying patterns.

* Seasonal plot: The mining trend shows little evidence of month-to-month seasonality, with no particular month standing out, though its overall level varies between years.

* Seasonal sub-series plot: The plot further confirms the absence of a dominant seasonal pattern, as each month shows a similar shape and the monthly means remain relatively flat and near zero.

* ACF plot: Significant autocorrelation at lags 1–3 suggests strong dependence between months. The gradual decay of the ACF indicates long-term memory, meaning current mining trends are influenced by many prior months.

* Summary stat: The series predominantly remains below zero, is right-skewed with large positive spikes and shows distinct regime shifts, indicating it is a non-stationary process.

```{r}
# auto plot 
mining_trend |> 
  autoplot(mining) + 
  labs(title = "Mining Trend", x = "Month", y = "Index") 

# seasonal plot 
mining_trend |> 
  gg_season(mining) +  
  labs(title = "Seasonal Plot of Mining Trend", x = "Month", y = "Index")

# seasonal sub-series plot 
mining_trend |> 
  gg_subseries(mining) +
  labs(title = "Seasonal Subseries Plot of Mining Trend", x = "Month", y = "Index")

# ACF plot 
mining_trend |> 
  ACF(mining) |> 
  autoplot() +
  labs(title = "ACF of Mining Trend", x = "Lag",y = "ACF")

# summary stat 
summary(mining_trend$mining)
cat("Standard Deviation:", sd(mining_trend$mining), "\n")
```

## Model Fitting 

```{r eval = FALSE}
# ECM 
# Result shows no cointegration found
city <- city_indexes |> 
  transmute(
    month = yearmonth(floor_date(as.Date(month_date), "month")),
    bris = as.numeric(greater_brisbane),
    syd  = as.numeric(greater_sydney)
  ) |>
  as_tsibble(index = month) 

# ADF test 
adf_bris_lvl <- ur.df(city$bris, type="trend", selectlags="AIC")
adf_syd_lvl  <- ur.df(city$syd,  type="trend", selectlags="AIC")
adf_bris_diff<- ur.df(diff(city$bris), type="none", selectlags="AIC")
adf_syd_diff <- ur.df(diff(city$syd),  type="none", selectlags="AIC")

# Long-run regression (Bris on Syd)
cn_lm <- lm(bris ~ syd, data = as.data.frame(city))
alpha <- coef(cn_lm)[2]
ect   <- resid(cn_lm)     

# ADF on residuals 
adf_ect <- ur.df(ect, type="none", selectlags="AIC")
summary(adf_ect)        
```


### ARIMA models 
```{r}
# Unitroot test 
unitroot_nsdiffs(mining_trend$mining)
unitroot_ndiffs(mining_trend$mining) #suggested d = 1 

# Plan A: Piecewise ARIMA with step dummies (WIP)

# Plan B: STL + ARIMA 
#mining_stl <- mining_trend |> 
 # model(stl = STL(mining))

#mining_stl |> 
 # components() |> 
  #autoplot() +
  #labs(title = "STL Decomposition of Mining Trend")

modb <- mining_trend %>%
  model(STL_ARIMA =
          decomposition_model(
            STL(mining ~ season(window = "periodic")),
            ARIMA(season_adjust, stepwise=FALSE, approximation=FALSE),
            SNAIVE(season_year)
          ))

report(modb)
gg_tsresiduals(modb)

fcb <- forecast(modb, h = 12)
autoplot(fcb, mining_trend)
```




